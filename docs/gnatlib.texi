\input texinfo  @c -*-texinfo-*-
@input texiplus

@setfilename gnatlib.info
@set Version 0.1
@set gnatlib GnatLib
@set Title   @value{gnatlib}: Library for Ada applications

@c --------------------------- macros
@macro CODESAMPLE{TXT}
@ifhtml
@smallexample
@group
\TXT\
@end group
@end smallexample
@end ifhtml
@ifnothtml
@cartouche
@smallexample
@group
\TXT\
@end group
@end smallexample
@end cartouche
@end ifnothtml
@end macro

@macro TIP{TXT}
@ifhtml
@html
<div class="tip">
@end html
\TXT\
@html
</div>
@end html
@end ifhtml
@ifnothtml
@quotation
@noindent
@image{tip,15pt}  \TXT\
@end quotation
@end ifnothtml
@end macro

@macro IMPORTANT{TXT}
@ifhtml
@html
<div class="important">
@end html
\TXT\
@html
</div>
@end html
@end ifhtml
@ifnothtml
@quotation
@noindent
@image{important,15pt}  \TXT\
@end quotation
@end ifnothtml
@end macro

@macro NOTE{TXT}
@ifhtml
@html
<div class="note">
@end html
\TXT\
@html
</div>
@end html
@end ifhtml
@ifnothtml
@quotation
@noindent
@image{note,15pt}  \TXT\
@end quotation
@end ifnothtml
@end macro
@c ---------------------------

@settitle @value{Title}
@setchapternewpage odd
@syncodeindex fn cp

@titlepage
@flushleft
@title @value{Title}
@end flushleft
@subtitle Version @value{Version}
@author AdaCore
@page
@vskip 0pt plus 1filll

Copyright @copyright{} 2007, AdaCore

This document may be copied, in whole or in part, in any form or by any
means, as is or with alterations, provided that (1) alterations are clearly
marked as alterations and (2) this copyright notice is included
unmodified in any copy.
@end titlepage

@ifnottex
@node Top,, (dir), (dir)
@top @value{Title}

Version @value{Version}

Copyright @copyright{} 2007, AdaCore

This document may be copied, in whole or in part, in any form or by any
means, as is or with alterations, provided that (1) alterations are clearly
marked as alterations and (2) this copyright notice is included
unmodified in any copy.

@menu
* Introduction::
* Building GnatLib::
* Embedding script languages:: The scripting module.
* Index::

@detailmenu
 --- The Detailed Node Listing ---

Introduction

Building @value{gnatlib}

Embedding script languages
* Supported languages::
* Scripts API::

Supported languages
* The Shell language::
* The Python language::
* Classes exported to all languages::

Scripts API

@end detailmenu
@end menu
@end ifnottex

@iftex
@contents
@end iftex

@c -----------------------------------------------------------------------
@node Introduction
@chapter Introduction
@c -----------------------------------------------------------------------

@noindent
The @value{gnatlib} library provides a number of modules that can be reused in
your own applications to add extra features or help implementation.

The modules that are currently provided are:
@table @asis
@item Script languages
This module allows you to embed one or more scripting languages in your
application, thus providing extensibility to users (@pxref{Embedding script
languages})

@end table

@c -----------------------------------------------------------------------
@node Building GnatLib
@chapter Building @value{gnatlib}
@c -----------------------------------------------------------------------

@noindent
If you didn't get a pre-compiled version of @value{gnatlib}, you will need
to compile and install it on your system yourself.

The compilation process tries to be as flexible as possible. You can choose
what modules to build, what features they should have,@dots{} This
flexibility comes at the cost of a certain complexity in the build
architecture, but that should be mostly transparent to you.

@IMPORTANT{@value{gnatlib} requires a fairly recent Ada05 compatible compiler.
If you do not have such a compiler, please contact @email{sales@@adacore.com}}

@noindent
Since you are reading this documentation, it is assumed you have been able
to unpack the package in a temporary directory. In the following instructions,
we will assume the following: @var{prefix} is the directory in which you
would like to install @value{gnatlib}.

@subsubsection Configuring the build environment

The first step is to configure the build environment. This is done by
running the @code{configure} command in the root directory of the
@value{gnatlib} tree. This command accepts lots of arguments, among which
the following ones are most useful:

@table @code
@item --prefix=@var{prefix}
This specifies the directory in which @value{gnatlib} should be installed.

@item --with-python=@var{directory}
@itemx --without-python
This specifies where @value{gnatlib} should find python. If for instance
the python executable is in @file{/usr/bin}, the @var{directory} to
specify is @file{/usr}. In most cases, however, @code{configure} will be
able to detect this automatically, so this is only useful if python is
installed in unusual directories. If you specify the second option,
support for python will not be build in.

@item --disable-pygtk
If this switch is specified, then support for pygtk (@pxref{The Python
language}) will not be build. The support for this python module will also
be automatically disabled if python was not found or if you configured with
@code{--without-python}.

@end table

Special support exists in @value{gnatlib} for the gtk+ graphical toolkit.
@code{configure} will attempt to find the installation directory for this
toolkit by using the @code{pkg-config} command, which must therefore be
available through your @var{PATH} environment variable.

@smallexample
./configure --prefix=/usr/local/gnatlib --without-python
@end smallexample

If all goes well (ie all required dependencies are found on the system),
configure will generate a number of files, including @file{Makefile},
@file{Makefile.conf} and @file{gnatlib_shared.gpr}.

@subsubsection Building @value{gnatlib}

If @code{configure} has run successfully, it generates a @code{Makefile}
to allow you to build the rest of @value{gnatlib}.
This is done by simply typing the following command:

@smallexample
make
@end smallexample

Optionally, you can also build the examples and/or the automatic testsuite,
with the following commands:

@smallexample
make examples
make tests
@end smallexample

@subsubsection Installing @value{gnatlib}

For now, you will need to manually copy the files from @file{scripts/obj}
into the installation directory.

Your application can now use the @value{gnatlib} code in several ways:

@itemize @bullet
@item If you are using the GNAT project files, you can add a with clause
to either @file{gnatlib.gpr} or @file{gnatlib_gtk.gpr}. The latter will also
force your application to be linked with the gtk+ libraries, but provides
additional capabilities as documented in each of the modules.

You can also add a dependency on @file{gnatlib_shared.gpr}, and use the
variables defined in that project that specify the additional libraries to
use when linking your application (in particular the python libraries if
support for python was build in).

@item If you are using a @file{Makefile}, you should include the file
@file{Makefile.conf} which was generated by configure. This defines a
number of variables that can then be used to compile source files or
link your application. Look at the @value{gnatlib} examples for examples
on how to compile an application.

@end itemize

@c ------------------------------------------------------------------------
@node Embedding script languages
@chapter Embedding script languages
@c ------------------------------------------------------------------------

@noindent
In a lot of contexts, you want to give the possibility to users to extend
your application. This can be done in several ways: define an Ada API from
which they can build dynamically loadable modules, provide the whole source
code to your application and let users recompile it, interface with a simpler
scripting languages,@dots{}

Dynamically loadable modules can be loaded on demand, as their name indicate.
However, they generally require a relatively complex environment to build,
and are somewhat less portable. But when your users are familiar with Ada,
they provide a programming environment in which they are comfortable.
As usual, changing the module requires recompilation, reinstallation,...

Providing the source code to your application is generally even more
complex for users. This requires an even more complex setup, your application
is generally too big for users to dive into, and modifications done by one
users are hard to provide to other users, or will be lost when you
distribute a new version of your application.

The third solution is to embed one or more scripting languages in your
application, and export some functions to it. This often requires your users
to learn a new language, but these languages are generally relatively simple,
and since they are interpreted they are easier to learn in an interactive
console. The resulting scripts can easily be redistributed to other users or
even distributed with future versions of your application.

The module in @value{gnatlib} helps you implement the third solution. It was
used extensively in the GPS programming environment for its python interface.

This module can be compiled with any of these languages as an optional
dependency (except for the shell language, which is always built-in, but is
extremely minimal, and doesn't have to be loaded at run time anyway).
If the necessary libraries are found on the system, @value{gnatlib} will
be build with support for the corresponding language, but your application
can chose at run time whether or not to activate the support for a specific
language.

Likewise, extensions are provided if the gtk+ libraries were found on your
system. These provide a number of Ada subprograms that help interface with
code using this library, and help export the corresponding classes.
This support for gtk+ is also optional, and you can still build
@value{gnatlib} even if gtk+ wasn't installed on your system (or if your
application is text-only, in which case you likely do not want to depend
at link time on graphical libraries).

@cindex test driver
@cindex testing your application
@TIP{Embedding a scripting language is often useful if you want to write
@emph{automatic tests} for an application or a library. Your Ada code can then
export the minimum set of classes and methods to the scripting language,
and advanced tests can quickly be written using these exported methods.
For instance, this has been used for the GPS environment, which is a
graphical application, to write such tests that simulate the click on
a button, the selection of a menu,@dots{}}

@menu
* Supported languages::
* Scripts API::
@end menu

@c -----------------------------------------------------------------------
@node Supported languages
@section Supported languages
@c -----------------------------------------------------------------------

@noindent
The module provides built-in support for several scripting languages, and
other languages can "easily" be added. Your application does not change
when new languages are added, since the interface to export subprograms
and classes to the scripting languages is language-neutral, and will
automatically export to all known scripting languages.

Support is provided for the following languages:

@table @b
@item Shell

This is a very simple-minded scripting language, which doesn't provide
flow-control instructions (@pxref{The Shell language}).

@item Python

Python (@url{http://www.python.org}) is an advanced scripting language
that comes with an extensive library. It is fully object-oriented
(@pxref{The Python language}).

@end table

@menu
* The Shell language::
* The Python language::
* Classes exported to all languages::
@end menu

@c ----------------------------------------------------------------------
@node The Shell language
@subsection The Shell language
@c ----------------------------------------------------------------------

@noindent
The shell language was initially developped in the context of the GPS
programming environment, as a way to embed scripting commands in XML
configuration files.

In this language, you can execute any of the commands exported by the
application, passing any number of arguments they need. Arguments to function
calls can, but need not, be quoted. Quoting is only mandatory when they
contain spaces, newline characters, or double-quotes ('"'). To quote an
argument, surround it by double-quotes, and precede each double-quote it
contains by a backslash character. Another way of quoting is similar to
what python provides, which is to triple-quote the argument, ie surround it
by '"""' on each side. In such a case, any special character (in particular
other double-quotes or backslashes) lose their special meaning and are just
taken as part of the argument. This is in particular useful when you do not
know in advance the contents of the argument you are quoting.

@CODESAMPLE{
Shell> function_name arg1 "arg 2" """arg 3"""
}

Commands are executed as if on a stack machine: the result of a command is
pushed on the stack, and later commands can reference it using @code{%}
following by a number. By default, the number of previous results that are
kept is set to 9, and this can only be changed by modifying the source code
for @value{gnatlib}. The return values are also modified by commands executed
internally by your application, and that might have no visible output from
the user's point of view. As a result, you should never assume you know
what @code{%1},@dots{} contain unless you just executed a command in the
same script.

@CODESAMPLE{
Shell> function_name arg1
Shell> function2_name %1
}

In particular, the @var{%1} syntax is used when emulating object-oriented
programming in the shell. A method of a class is just a particular function
that contains a '.' in its name, and whose first implict argument is the
instance on which it applies. This instance is generally the result of
calling a constructor in an earlier call. Assuming, for instance, that we
have exported a class "Base" to the shell from our Ada core, we could use
the following code:
@CODESAMPLE{
Shell> Base arg1 arg2
Shell> Base.method %1 arg1 arg2
}
to create an instance and call one of its methods.
Of course, the shell is not the best language for object-oriented programming,
and better languages should be used instead.

Some commands are automatically added to the shell when this scripting
language is added to the application. These are

@deffn Function load file
Loads the content of @var{file} from the disk, and execute each of its lines as
a Shell command. This can for instance be used to load scripts when your
application is loaded
@end deffn

@deffn Function echo arg@dots{}
This function takes any number of argument, and prints them in the console
associated with the language. By default, when in an interactive console, the
output of commands is automatically printed to the console. But when you
execute a script through @code{load} above, you need to explicitly call
@code{echo} to make some output visible.
@end deffn

@deffn Function clear_cache
This frees the memory used to store the output of previous commands. Calling
@var{%1} afterward will not make sense until further commands are executed.
@end deffn

@c ----------------------------------------------------------------------
@node The Python language
@subsection The Python language
@c ----------------------------------------------------------------------

@cindex Python 
@noindent
Python is an interpreted, object-oriented language. See
@url{http://www.python.org} for more information, including tutorials, on
this language.

@NOTE{
Python support is optional in @value{gnatlib}. If it hasn't been installed
on your system, @value{gnatlib} will be compiled without it, but that
will not impact applications using @value{gnatlib}, since the same packages
(and the same API therein) are provided in both cases. Of course, if python
support wasn't compiled in, these packages will do nothing.
}

@noindent
@cindex GNAT.Python 
@cindex gnat-python.ads 
In addition to the API common to all languages (@pxref{Scripts API}),
@value{gnatlib} also comes with a low-level interface to the python
library. This interface is available in the @file{GNAT.Python} package.
In general, it is much simpler to use the common API rather than this
specialized one, though, since otherwise you will need to take care of lots
of details like memory management, conversion to and from python types,@dots{}

All functions exported to python through @value{gnatlib} are available in
a single python module, whose name you must specify when adding support
for python. This is done to avoid namespace pollution. You can further
organize the subprograms through python classes to provide more logical
namespaces.

As in Ada, python lets you use named parameters in subprogram calls,
and thus let's you change the order of arguments on the command line.
This is fully supported by @value{gnatlib}, although your callbacks will
need to specify the name of the parameters for this to work fine.
@CODESAMPLE{
>>> func_name (arg1, arg2)
>>> func_name (arg2=arg2, arg1=arg1)`
}

Some commands and types are always exported by @value{gnatlib}, since they
are needed by most application, or even internally by @value{gnatlib}
itself.

@deffn  Exception Unexpected_Exception
@deffnx Exception Exception
@deffnx Exception Missing_Arguments
@deffnx Exception Invalid_Argument
A number of exceptions are added automatically, so that the internal
state of your application is reflected in python. These are raised on
unexpected uncaught Ada exceptions, when your callbacks return explicit
errors, or when a function call is missing some arguments.
@end deffn

@deffn Function exec_in_console command
This function can be used in your script when you need to modify the
contents of the python interpreter itself.

When you run a python script, all its commands (including the global
variables) are within the context of the script. Therefore, you cannot
affect variables which are used for instance in the rest of your
application or in the python console. With this function, @var{command}
will be executed as if it had been typed in the python console.

@example
exec_in_console ("sys.ps1 = 'foo'")
	@result{} foo>  # Prompt was changed in the console
@end example
@end deffn

@cindex pygtk
PyGtk is a python extension that provides an interface to the popular
gtk+ library. It gives access to a host of functions for writing graphical
interfaces from python. @value{gnatlib} interfaces nicely with this extension
if it is found.

@NOTE{PyGtk support is also optional. It will be activated in your application
if the four following conditions are met: Python was detected on your system,
PyGtk was also detected when @value{gnatlib} is built, PyGtk is detected
dynamically when your application is launched and your code is calling the
@code{Init_PyGtk_Support} function
@c @end itemize
}

When PyGtk is detected, you can add the following method to any of the
classes you export to python:

@defmethod AnyClass pywidget
This function returns an instance of a PyGtk class corresponding to the
graphical object represented by @var{AnyClass}. In general, it makes sense when
@var{AnyClass} is bound, in your Ada code, to a GtkAda object. As a result, the
same graphical element visible to the user on the screen is available from
three different programming languages: C, Ada and Python. All three can
manipulate it in the same way
@end defmethod

@c ----------------------------------------------------------------------
@node Classes exported to all languages
@subsection Classes exported to all languages
@c ----------------------------------------------------------------------

@noindent
In addition to the functions exported by each specific scripting language,
as described above, @value{gnatlib} exports the following to all the
scripting languages. These are exported when your Ada code calls the
Ada procedure @code{GNAT.Scripts.Register_Standard_Classes}, which should
done after you have loaded all the scripting languages.

@deftp Class Console
@code{Console} is a name that you can chose yourself when you call the
above Ada procedure. It will be assumed to be @code{Console} in the rest
of this document.

This class provides an interface to consoles. A console is an input/output
area in your application (whether it is a text area in a graphical
application, or simply standard text I/O in text mode). In particular,
the python standard output streams @code{sys.stdin}, @code{sys.stdout}
and @code{sys.stderr} are redirected to an instance of that class. If you
want to see python's error messages or usual output in your application,
you must register that class, and define a default console for your
scripting language through calls to @code{GNAT.Scripts.Set_Default_Console}.
@end deftp

@defmethod Console write text
This method writes @var{text} to the console associated with the class
instance. See the examples delivered with @value{gnatlib} for examples on
how to create a graphical window and make it into a @code{Console}.
@end defmethod

@defmethod Console clear
Clears the contents of the console.
@end defmethod

@defmethod Console flush
Does nothing currently, but is needed for compatibility with python.
Output through @code{Console} instances is not buffered anyway.
@end defmethod

@deftypemethod Console boolean isatty
Whether the console is a pseudo-terminal. This is always wrong in the
case of @value{gnatlib}.
@end deftypemethod

@deftypemethod Console string read [size]
Reads at most @var{size} bytes from the console, and returns the resulting
string.
@end deftypemethod

@deftypemethod Consonle string readline [size]
Reads at most @var{size} lines from the console, and returns them as a single
string.
@end deftypemethod

@c -----------------------------------------------------------------------
@node Scripts API
@section Scripts API
@c -----------------------------------------------------------------------

@noindent
This section will give an overview of the API used in the scripts module.
The reference documentation for this API is in the source files themselves. In
particular, each @file{.ads} file fully documents all its public API.

@c -----------------------------------------------------------------------
@node Index
@unnumbered Index
@printindex cp
@bye

@c To be documented:
@c - using factories to make sure the same instance is always returned for
@c   the same Ada type. This is good practice not enforced by gnatlib
@c - API documentation

