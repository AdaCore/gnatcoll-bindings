\input texinfo  @c -*-texinfo-*-
@input texiplus

@setfilename gnatlib.info
@set Version 0.1
@set gnatlib GnatLib
@set Title   @value{gnatlib}: Library for Ada applications

@c --------------------------- macro
@c This macro can be used to insert code sample. Each line should end with
@c @NL{}, since otherwise texinfo doesn't guarantee that newlines will be
@c preserved
@macro CODESAMPLE{TXT}
@ifhtml
@smallexample
@group
\TXT\
@end group
@end smallexample
@end ifhtml
@ifnothtml
@cartouche
@example
@group
\TXT\
@end group
@end example
@end cartouche
@end ifnothtml
@end macro

@c simulates a newline when in a @CODESAMPLE
@macro NL{}
@end macro

@c --------------------------- macro
@c This macro can be used to insert a "Tip" or "Did you know" box. In HTML,
@c this box is displayed in the right margin of the text, and thus doesn't
@c disturbs the normal reading flow, but provides additional useful
@c information. A small icon is displayed on the left of the box
@macro TIP{TXT}
@ifhtml
@html
<div class="tip">
@end html
\TXT\
@html
</div>
@end html
@end ifhtml
@ifnothtml
@quotation
@noindent
@image{tip,15pt}  \TXT\
@end quotation
@end ifnothtml
@end macro

@c -------------------------- macro
@c This macro can be used to insert an "Important" box in the text.
@c This box is displayed inline in the main body of the text, but is
@c surrounded by a frame, and has a small icon on the left.
@macro IMPORTANT{TXT}
@ifhtml
@html
<div class="important">
@end html
\TXT\
@html
</div>
@end html
@end ifhtml
@ifnothtml
@quotation
@noindent
@image{important,15pt}  \TXT\
@end quotation
@end ifnothtml
@end macro

@c ------------------------- macro
@c This macro can be used to insert a "Note" box in the text. It is
@c displayed inline in the main body of the text, but has a different
@c icon that the "Important" box
@macro NOTE{TXT}
@ifhtml
@html
<div class="note">
@end html
\TXT\
@html
</div>
@end html
@end ifhtml
@ifnothtml
@quotation
@noindent
@image{note,15pt}  \TXT\
@end quotation
@end ifnothtml
@end macro
@c ---------------------------

@settitle @value{Title}
@setchapternewpage odd
@syncodeindex fn cp
@syncodeindex vr cp

@titlepage
@flushleft
@title @value{Title}
@end flushleft
@subtitle Version @value{Version}
@author AdaCore
@page
@vskip 0pt plus 1filll

Copyright @copyright{} 2007, AdaCore

This document may be copied, in whole or in part, in any form or by any
means, as is or with alterations, provided that (1) alterations are clearly
marked as alterations and (2) this copyright notice is included
unmodified in any copy.
@end titlepage

@ifnottex
@node Top,, (dir), (dir)
@top @value{Title}

Version @value{Version}

Copyright @copyright{} 2007, AdaCore

This document may be copied, in whole or in part, in any form or by any
means, as is or with alterations, provided that (1) alterations are clearly
marked as alterations and (2) this copyright notice is included
unmodified in any copy.

@menu
* Introduction::
* Building GnatLib::
* Embedding script languages:: The scripting module.
* Index::

@ifnothtml
@detailmenu
 --- The Detailed Node Listing ---

Introduction

Building GnatLib

Embedding script languages
* Supported languages::
* Scripts API::

Supported languages
* The Shell language::
* The Python language::
* Classes exported to all languages::

Scripts API
* Initializing the scripting module::

@end detailmenu
@end ifnothtml
@end menu
@end ifnottex

@iftex
@contents
@end iftex
@ifhtml
@contents
@end ifhtml

@c -----------------------------------------------------------------------
@node Introduction
@chapter Introduction
@c -----------------------------------------------------------------------

@noindent
The @value{gnatlib} library provides a number of modules that can be reused in
your own applications to add extra features or help implementation.

The modules that are currently provided are:
@table @asis
@item Script languages
This module allows you to embed one or more scripting languages in your
application, thus providing extensibility to users (@pxref{Embedding script
languages})

@end table

@c -----------------------------------------------------------------------
@node Building GnatLib
@chapter Building @value{gnatlib}
@c -----------------------------------------------------------------------

@noindent
If you didn't get a pre-compiled version of @value{gnatlib}, you will need
to compile and install it on your system yourself.

The compilation process tries to be as flexible as possible. You can choose
what modules to build, what features they should have,@dots{} This
flexibility comes at the cost of a certain complexity in the build
architecture, but that should be mostly transparent to you.

@IMPORTANT{@value{gnatlib} requires a fairly recent Ada05 compatible compiler.
If you do not have such a compiler, please contact @email{sales@@adacore.com}}

@noindent
Since you are reading this documentation, it is assumed you have been able
to unpack the package in a temporary directory. In the following instructions,
we will assume the following: @var{prefix} is the directory in which you
would like to install @value{gnatlib}.

@section Configuring the build environment

The first step is to configure the build environment. This is done by
running the @code{configure} command in the root directory of the
@value{gnatlib} tree. This command accepts lots of arguments, among which
the following ones are most useful:

@table @code
@item --prefix=@var{prefix}
This specifies the directory in which @value{gnatlib} should be installed.

@item --with-python=@var{directory}
@itemx --without-python
This specifies where @value{gnatlib} should find python. If for instance
the python executable is in @file{/usr/bin}, the @var{directory} to
specify is @file{/usr}. In most cases, however, @code{configure} will be
able to detect this automatically, so this is only useful if python is
installed in unusual directories. If you specify the second option,
support for python will not be build in.

@item --disable-pygtk
If this switch is specified, then support for pygtk (@pxref{The Python
language}) will not be build. The support for this python module will also
be automatically disabled if python was not found or if you configured with
@code{--without-python}.

@end table

Special support exists in @value{gnatlib} for the gtk+ graphical toolkit.
@code{configure} will attempt to find the installation directory for this
toolkit by using the @code{pkg-config} command, which must therefore be
available through your @var{PATH} environment variable.

@smallexample
./configure --prefix=/usr/local/gnatlib --without-python
@end smallexample

If all goes well (i.e. all required dependencies are found on the system),
configure will generate a number of files, including @file{Makefile},
@file{Makefile.conf} and @file{gnatlib_shared.gpr}.

@section Building @value{gnatlib}

If @code{configure} has run successfully, it generates a @code{Makefile}
to allow you to build the rest of @value{gnatlib}.
This is done by simply typing the following command:

@smallexample
make
@end smallexample

Optionally, you can also build the examples and/or the automatic test suite,
with the following commands:

@smallexample
make examples
make tests
@end smallexample

@section Installing @value{gnatlib}

For now, you will need to manually copy the files from @file{scripts/obj}
into the installation directory.

Your application can now use the @value{gnatlib} code in several ways:

@itemize @bullet
@item If you are using the GNAT project files, you can add a with clause
to either @file{gnatlib.gpr} or @file{gnatlib_gtk.gpr}. The latter will also
force your application to be linked with the gtk+ libraries, but provides
additional capabilities as documented in each of the modules.

You can also add a dependency on @file{gnatlib_shared.gpr}, and use the
variables defined in that project that specify the additional libraries to
use when linking your application (in particular the python libraries if
support for python was build in).

@item If you are using a @file{Makefile}, you should include the file
@file{Makefile.conf} which was generated by configure. This defines a
number of variables that can then be used to compile source files or
link your application. Look at the @value{gnatlib} examples for examples
on how to compile an application.

@end itemize

@c ------------------------------------------------------------------------
@node Embedding script languages
@chapter Embedding script languages
@c ------------------------------------------------------------------------

@noindent
In a lot of contexts, you want to give the possibility to users to extend
your application. This can be done in several ways: define an Ada API from
which they can build dynamically loadable modules, provide the whole source
code to your application and let users recompile it, interface with a simpler
scripting languages,@dots{}

Dynamically loadable modules can be loaded on demand, as their name indicate.
However, they generally require a relatively complex environment to build,
and are somewhat less portable. But when your users are familiar with Ada,
they provide a programming environment in which they are comfortable.
As usual, changing the module requires recompilation, re-installation,...

Providing the source code to your application is generally even more
complex for users. This requires an even more complex setup, your application
is generally too big for users to dive into, and modifications done by one
users are hard to provide to other users, or will be lost when you
distribute a new version of your application.

The third solution is to embed one or more scripting languages in your
application, and export some functions to it. This often requires your users
to learn a new language, but these languages are generally relatively simple,
and since they are interpreted they are easier to learn in an interactive
console. The resulting scripts can easily be redistributed to other users or
even distributed with future versions of your application.

The module in @value{gnatlib} helps you implement the third solution. It was
used extensively in the GPS programming environment for its python interface.

@TIP{Each of the scripting language is optional}
This module can be compiled with any of these languages as an optional
dependency (except for the shell language, which is always built-in, but is
extremely minimal, and doesn't have to be loaded at run time anyway).
If the necessary libraries are found on the system, @value{gnatlib} will
be build with support for the corresponding language, but your application
can chose at run time whether or not to activate the support for a specific
language.

@TIP{Optional support is provided for the @emph{gtk+} library}.
Likewise, extensions are provided if the gtk+ libraries were found on your
system. These provide a number of Ada subprograms that help interface with
code using this library, and help export the corresponding classes.
This support for gtk+ is also optional, and you can still build
@value{gnatlib} even if gtk+ wasn't installed on your system (or if your
application is text-only, in which case you likely do not want to depend
at link time on graphical libraries).

@cindex test driver
@cindex testing your application
@TIP{Use a scripting language to provide an automatic testing framework for
your application.}
@noindent
The GPS environment uses python command for its @emph{automatic test suite},
including graphical tests such as pressing on a button, selecting a
menu,@dots{}

@menu
* Supported languages::
* Scripts API::
@end menu

@c -----------------------------------------------------------------------
@node Supported languages
@section Supported languages
@c -----------------------------------------------------------------------

@noindent
The module provides built-in support for several scripting languages, and
other languages can "easily" be added. Your application does not change
when new languages are added, since the interface to export subprograms
and classes to the scripting languages is language-neutral, and will
automatically export to all known scripting languages.

Support is provided for the following languages:

@table @b
@item Shell

This is a very simple-minded scripting language, which doesn't provide
flow-control instructions (@pxref{The Shell language}).

@item Python

Python (@url{http://www.python.org}) is an advanced scripting language
that comes with an extensive library. It is fully object-oriented
(@pxref{The Python language}).

@end table

@menu
* The Shell language::
* The Python language::
* Classes exported to all languages::
@end menu

@c ----------------------------------------------------------------------
@node The Shell language
@subsection The Shell language
@c ----------------------------------------------------------------------

@noindent
The shell language was initially developed in the context of the GPS
programming environment, as a way to embed scripting commands in XML
configuration files.

In this language, you can execute any of the commands exported by the
application, passing any number of arguments they need. Arguments to function
calls can, but need not, be quoted. Quoting is only mandatory when they
contain spaces, newline characters, or double-quotes ('"'). To quote an
argument, surround it by double-quotes, and precede each double-quote it
contains by a backslash character. Another way of quoting is similar to
what python provides, which is to triple-quote the argument, i.e. surround it
by '"""' on each side. In such a case, any special character (in particular
other double-quotes or backslashes) lose their special meaning and are just
taken as part of the argument. This is in particular useful when you do not
know in advance the contents of the argument you are quoting.

@CODESAMPLE{
Shell> function_name arg1 "arg 2" """arg 3"""
}

Commands are executed as if on a stack machine: the result of a command is
pushed on the stack, and later commands can reference it using @code{%}
following by a number. By default, the number of previous results that are
kept is set to 9, and this can only be changed by modifying the source code
for @value{gnatlib}. The return values are also modified by commands executed
internally by your application, and that might have no visible output from
the user's point of view. As a result, you should never assume you know
what @code{%1},@dots{} contain unless you just executed a command in the
same script.

@CODESAMPLE{
Shell> function_name arg1
Shell> function2_name %1
}

In particular, the @var{%1} syntax is used when emulating object-oriented
programming in the shell. A method of a class is just a particular function
that contains a '.' in its name, and whose first implicit argument is the
instance on which it applies. This instance is generally the result of
calling a constructor in an earlier call. Assuming, for instance, that we
have exported a class "Base" to the shell from our Ada core, we could use
the following code:
@CODESAMPLE{
Shell> Base arg1 arg2
Shell> Base.method %1 arg1 arg2
}
to create an instance and call one of its methods.
Of course, the shell is not the best language for object-oriented programming,
and better languages should be used instead.

Some commands are automatically added to the shell when this scripting
language is added to the application. These are

@deffn Function load file
Loads the content of @var{file} from the disk, and execute each of its lines as
a Shell command. This can for instance be used to load scripts when your
application is loaded
@end deffn

@deffn Function echo arg@dots{}
This function takes any number of argument, and prints them in the console
associated with the language. By default, when in an interactive console, the
output of commands is automatically printed to the console. But when you
execute a script through @code{load} above, you need to explicitly call
@code{echo} to make some output visible.
@end deffn

@deffn Function clear_cache
This frees the memory used to store the output of previous commands. Calling
@var{%1} afterward will not make sense until further commands are executed.
@end deffn

@c ----------------------------------------------------------------------
@node The Python language
@subsection The Python language
@c ----------------------------------------------------------------------

@cindex Python 
@noindent
Python is an interpreted, object-oriented language. See
@url{http://www.python.org} for more information, including tutorials, on
this language.

@NOTE{
Python support is optional in @value{gnatlib}. If it hasn't been installed
on your system, @value{gnatlib} will be compiled without it, but that
will not impact applications using @value{gnatlib}, since the same packages
(and the same API therein) are provided in both cases. Of course, if python
support wasn't compiled in, these packages will do nothing.
}

@noindent
@cindex GNAT.Python 
@cindex gnat-python.ads 
In addition to the API common to all languages (@pxref{Scripts API}),
@value{gnatlib} also comes with a low-level interface to the python
library. This interface is available in the @file{GNAT.Python} package.
In general, it is much simpler to use the common API rather than this
specialized one, though, since otherwise you will need to take care of lots
of details like memory management, conversion to and from python types,@dots{}

@TIP{All functions exported to python are available in a specific namespace}
@noindent
All functions exported to python through @value{gnatlib} are available in
a single python module, whose name you must specify when adding support
for python. This is done to avoid namespace pollution. You can further
organize the subprograms through python classes to provide more logical
namespaces.

As in Ada, python lets you use named parameters in subprogram calls,
and thus let's you change the order of arguments on the command line.
This is fully supported by @value{gnatlib}, although your callbacks will
need to specify the name of the parameters for this to work fine.
@CODESAMPLE{
>>> func_name (arg1, arg2)
>>> func_name (arg2=arg2, arg1=arg1)`
}

Some commands and types are always exported by @value{gnatlib}, since they
are needed by most application, or even internally by @value{gnatlib}
itself.

@deffn  Exception Unexpected_Exception
@deffnx Exception Exception
@deffnx Exception Missing_Arguments
@deffnx Exception Invalid_Argument
A number of exceptions are added automatically, so that the internal
state of your application is reflected in python. These are raised on
unexpected uncaught Ada exceptions, when your callbacks return explicit
errors, or when a function call is missing some arguments.
@end deffn

@deffn Function exec_in_console command
This function can be used in your script when you need to modify the
contents of the python interpreter itself.

When you run a python script, all its commands (including the global
variables) are within the context of the script. Therefore, you cannot
affect variables which are used for instance in the rest of your
application or in the python console. With this function, @var{command}
will be executed as if it had been typed in the python console.

@example
exec_in_console ("sys.ps1 = 'foo'")
	@result{} foo>  # Prompt was changed in the console
@end example
@end deffn

@cindex pygtk
PyGtk is a python extension that provides an interface to the popular
gtk+ library. It gives access to a host of functions for writing graphical
interfaces from python. @value{gnatlib} interfaces nicely with this extension
if it is found.

@NOTE{PyGtk support is also optional. It will be activated in your application
if the four following conditions are met: Python was detected on your system,
PyGtk was also detected when @value{gnatlib} is built, PyGtk is detected
dynamically when your application is launched and your code is calling the
@code{Init_PyGtk_Support} function
@c @end itemize
}

When PyGtk is detected, you can add the following method to any of the
classes you export to python:

@defmethod AnyClass pywidget
This function returns an instance of a PyGtk class corresponding to the
graphical object represented by @var{AnyClass}. In general, it makes sense when
@var{AnyClass} is bound, in your Ada code, to a GtkAda object. As a result, the
same graphical element visible to the user on the screen is available from
three different programming languages: C, Ada and Python. All three can
manipulate it in the same way
@end defmethod

@c ----------------------------------------------------------------------
@node Classes exported to all languages
@subsection Classes exported to all languages
@c ----------------------------------------------------------------------

@noindent
In addition to the functions exported by each specific scripting language,
as described above, @value{gnatlib} exports the following to all the
scripting languages. These are exported when your Ada code calls the
Ada procedure @code{GNAT.Scripts.Register_Standard_Classes}, which should
done after you have loaded all the scripting languages.

@deftp Class Console
@code{Console} is a name that you can chose yourself when you call the
above Ada procedure. It will be assumed to be @code{Console} in the rest
of this document.

This class provides an interface to consoles. A console is an input/output
area in your application (whether it is a text area in a graphical
application, or simply standard text I/O in text mode). In particular,
the python standard output streams @code{sys.stdin}, @code{sys.stdout}
and @code{sys.stderr} are redirected to an instance of that class. If you
want to see python's error messages or usual output in your application,
you must register that class, and define a default console for your
scripting language through calls to @code{GNAT.Scripts.Set_Default_Console}.

You can later add new methods to this class, which would be specific to your
application. Or you can derive this class into a new class to achieve a similar
goal.
@end deftp

@defmethod Console write text
This method writes @var{text} to the console associated with the class
instance. See the examples delivered with @value{gnatlib} for examples on
how to create a graphical window and make it into a @code{Console}.
@end defmethod

@defmethod Console clear
Clears the contents of the console.
@end defmethod

@defmethod Console flush
Does nothing currently, but is needed for compatibility with python.
Output through @code{Console} instances is not buffered anyway.
@end defmethod

@deftypemethod Console Boolean isatty
Whether the console is a pseudo-terminal. This is always wrong in the
case of @value{gnatlib}.
@end deftypemethod

@deftypemethod Console string read [size]
Reads at most @var{size} bytes from the console, and returns the resulting
string.
@end deftypemethod

@deftypemethod Console string readline [size]
Reads at most @var{size} lines from the console, and returns them as a single
string.
@end deftypemethod

@c -----------------------------------------------------------------------
@node Scripts API
@section Scripts API
@c -----------------------------------------------------------------------

@noindent
This section will give an overview of the API used in the scripts module.
The reference documentation for this API is in the source files themselves. In
particular, each @file{.ads} file fully documents all its public API.

As described above, @value{gnatlib} contains several levels of API. In
particular, it provides a low-level interface to python, in the packages
@code{GNAT.Python}. This interface is used by the rest of @value{gnatlib},
but is likely too low-level to really be convenient in your applications,
since you need to take care of memory management and type conversions by
yourself.

Instead, @value{gnatlib} provides a language-neutral Ada API. Using this
API, it is transparent for your application whether you are talking to the
Shell, to python, or to another language integrated in @value{gnatlib}.
The code remains exactly the same, and new scripting languages can be added
in later releases of @value{gnatlib} without requiring a change in your
application. This flexibility is central to the design of @value{gnatlib}.

In exchange for that flexibility, however, there are language-specific
features that cannot be performed through the @value{gnatlib} API. At
present, this includes for instance exporting functions that return hash
tables. But @value{gnatlib} doesn't try to export the greatest set of
features common to all languages. On the contrary, it tries to fully
support all the languages, and provide reasonable fallback for languages
that do not support that feature. For instance, named parameters (which
are a part of the python language) are fully supported, although the
shell language doesn't support them. But that's an implementation detail
transparent to your own application.

Likewise, your application might decide to always load the python
scripting language. If @value{gnatlib} wasn't compiled with python support,
the corresponding Ada function still exists (and thus your code still
compiles), although of course it does nothing. But since the rest of the
code is independent of python, this is totally transparent for your
application.

@TIP{@value{gnatlib} comes with some examples, which you can use
  as a reference when building your own application.
  See the @file{scripts/examples} directory.}

@noindent
Interfacing your application with the scripting module is a multistep
process:

@itemize @bullet
@item You @emph{must} @b{initialize} @value{gnatlib} and decide which features
  to load
@item You @emph{can} create an @b{interactive console} for the various
  languages, so that users can perform experiments interactively. This
  is optional, and you could decide to keep the scripting language has a
  hidden implementation detail (or just for automatic testing purposes
  for instance)
@item You @emph{can} @b{export} some classes and methods.
  This is optional, but it doesn't really make sense to just embed a
  scripting language and export nothing to it. In such a case, you might
  as well spawn a separate executable.
@item You @emph{can} load @b{start up scripts} or plug-ins that users have
  written to extend your application.
@end itemize

@menu
* Initializing the scripting module::
@end menu

@c -----------------------------------------------------------------------
@node Initializing the scripting module
@subsection Initializing the scripting module
@c -----------------------------------------------------------------------

@noindent
@value{gnatlib} must be initialized properly in order to provide added
value to your application. This cannot be done automatically simply by
depending on the library, since this initialization requires multiple-step
that must be done at specific moments in the initialization of your whole
application.

This initialization does not depend on whether you have build support
for python or for gtk+ in @value{gnatlib}. The same packages and subprograms
are available in all cases, and therefore you do not need conditional
compilation in your application to support the various cases.

@c -----------------------------------------------------------------------
@subsubsection Create the scripts repository
@c -----------------------------------------------------------------------
@noindent
The type @code{GNAT.Scripts.Scripts_Repository} will contain various
variables common to all the scripting languages, as well as a list of the
languages that were activated. This is the starting point for all other
types, since from there you have access to everything. You will have only
one variable of this type in your application, but it should generally be
available from all the code that interfaces with the scripting language.

Like the rest of @value{gnatlib}, this is a tagged type, which you can
extend in your own code. For instance, the GPS programming environment is
organized as a kernel and several option modules. The kernel provides
the core functionality of GPS, and should be available from most functions
that interface with the scripting languages. Since these functions have
very specific profiles, we cannot pass additional arguments to them. One
way to work around this limitation is to store the additional arguments
(in this case a pointer to the kernel) in a class derived from
@code{Scripts_Repository_Data}.

As a result, the code would look like

@CODESAMPLE{@b{with} GNAT.Scripts;@NL{}
Repo : Scripts_Repository := @b{new} Scripts_Repository_Data;}

@noindent
or, in the more complex case of GPS described above:

@CODESAMPLE{@b{type} Kernel_Scripts_Repository @b{is new}@NL{}
   Scripts_Repository_Data @b{with record}@NL{}
      Kernel : ...;@NL{}
@b{end record;}@NL{}
Repo : Scripts_Repository := new Kernel_Scripts_Repository'@NL{}
   (Scripts_Repository_Data @b{with} Kernel => ...);}

@c -----------------------------------------------------------------------
@subsubsection Loading the scripting language
@c -----------------------------------------------------------------------
@noindent
The next step is to decide which scripting languages should be made
available to users. This must be done before any function is exported,
since only functions exported after a language has been loaded will be
made available in that language.

@NOTE{If for instance python support was build into @value{gnatlib}, and
if you decide not to make it available to users, your application will
still be linked with @file{libpython}. It is therefore recommended although
not mandatory to only build those languages that you will use}

This is done through a simple call to one or more subprograms. The following
example registers both the shell and python languages

@CODESAMPLE{@b{with} GNAT.Scripts.Python;@NL{}
@b{with} GNAT.Scripts.Shell;@NL{}
Register_Shell_Scripting (Repo);@NL{}
Register_Python_Scripting (Repo, "MyModule");}


@deffn Procedure Register_Shell_Scripting Repo
This adds support for the shell language. Any class or function that is
now exported through @value{gnatlib} will be made available in the shell
@end deffn

@deffn Procedure Register_Python_Scripting Repo Module_Name
This adds support for the python language. Any class or function exported
from now on will be made available in python, in the module specified
by @var{Module_Name}
@end deffn

@c -----------------------------------------------------------------------
@subsubsection Exporting standard classes
@c -----------------------------------------------------------------------
@noindent
To be fully functional, @value{gnatlib} requires some predefined classes
to be exported to all languages (@pxref{Classes exported to all languages}).
For instance, the @code{Console} class is needed for proper interactive with
the consoles associated with each language.

These classes are created with the following code:
@CODESAMPLE{Register_Standard_Classes (Repo, "Console");}

This must be done only after all the scripting languages were loaded in the
previous step, since otherwise the new classes would not be visible in the
other languages.

@deffn Procedure Register_Standard_Classes Repo Console_Class
The second parameter @var{Console_Class} is the name of the class that
is bound to a console, and thus provides input/output support. You can chose
this name so that it matches the classes you intend to export later on from
your application.
@end deffn

@c -----------------------------------------------------------------------
@node Index
@unnumbered Index
@c -----------------------------------------------------------------------
@printindex cp
@bye

@c To be documented:
@c - using factories to make sure the same instance is always returned for
@c   the same Ada type. This is good practice not enforced by gnatlib
@c - API documentation

