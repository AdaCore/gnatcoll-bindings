\input texinfo  @c -*-texinfo-*-

@set Version 0.1
@set gnatlib GnatLib
@set Title   @value{gnatlib}: Library for Ada applications

@settitle @value{Title}
@syncodeindex fn cp

@titlepage
@title @value{Title}
@subtitle Version @value{Version}
@author AdaCore
@page
@vskip 0pt plus 1filll

Copyright @copyright{} 2007, AdaCore

This document may be copied, in whole or in part, in any form or by any
means, as is or with alterations, provided that (1) alterations are clearly
marked as alterations and (2) this copyright notice is included
unmodified in any copy.
@end titlepage

@ifnottex
@node Top,, (dir), (dir)
@top @value{Version}

@value{Version}

Version @value{Version}

Copyright @copyright{} 2007, AdaCore

This document may be copied, in whole or in part, in any form or by any
means, as is or with alterations, provided that (1) alterations are clearly
marked as alterations and (2) this copyright notice is included
unmodified in any copy.

@menu
* Introduction::
* Embedding script languages::

@detailmenu
 --- The Detailed Node Listing ---

Introduction

Embedding script languages
* Supported languages::

Supported languages
* The Shell language::
* The Python language::

@end detailmenu
@end menu
@end ifnottex

@iftex
@contents
@end iftex

@c -----------------------------------------------------------------------
@node Introduction
@chapter Introduction
@c -----------------------------------------------------------------------

@noindent
The @value{gnatlib} library provides a number of modules that can be reused in
your own applications to add extra features or help implementation.

The modules that are currently provided are:
@table @bullet
@item Script languages
This module allows you to embed one or more scripting languages in your
application, thus providing extensibility to users (@pxref{Embedding script
languages})

@end table

@c ------------------------------------------------------------------------
@node Embedding script languages
@chapter Embedding script languages
@c ------------------------------------------------------------------------

@noindent
In a lot of contexts, you want to give the possibility to users to extend
your application. This can be done in several ways: define an Ada API from
which they can build dynamically loadable modules, provide the whole source
code to your application and let users recompile it, interface with a simpler
scripting languages,@dots{}

Dynamically loadable modules can be loaded on demand, as their name indicate.
However, they generally require a relatively complex environment to build,
and are somewhat less portable. But when your users are familiar with Ada,
they provide a programming environment in which they are comfortable.
As usual, changing the module requires recompilation, reinstallation,...

Providing the source code to your application is generally even more
complex for users. This requires an even more complex setup, your application
is generally too big for users to dive into, and modifications done by one
users are hard to provide to other users, or will be lost when you
distribute a new version of your application.

The third solution is to embed one or more scripting languages in your
application, and export some functions to it. This often requires your users
to learn a new language, but these languages are generally relatively simple,
and since they are interpreted they are easier to learn in an interactive
console. The resulting scripts can easily be redistributed to other users or
even distributed with future versions of your application.

The module in @value{gnatlib} helps you implement the third solution. It was
used extensively in the GPS programming environment for its python interface.

@menu
* Supported languages::
@end menu

@c -----------------------------------------------------------------------
@node Supported languages
@section Supported languages
@c -----------------------------------------------------------------------

@noindent
The module provides built-in support for several scripting languages, and
other languages can "easily" be added. Your application does not change
when new languages are added, since the interface to export subprograms
and classes to the scripting languages is language-neutral, and will
automatically export to all known scripting languages.

Support is provided for the following languages:

@table @bullet
@item "Shell"

This is a very simple-minded scripting language, which doesn't provide
flow-control instructions (@pxref{The Shell language}).

@item "Python"

Python (@url{http://www.python.org}) is an advanced scripting language
that comes with an extensive library. It is fully object-oriented
(@pxref{The Python language}).

@end table

@menu
* The Shell language::
* The Python language::
@end menu

@c ----------------------------------------------------------------------
@node The Shell language
@subsection The Shell language
@c ----------------------------------------------------------------------

@noindent
It was initially developped in the context of the GPS programming environment,
as a way to embed scripting commands in XML configuration files.

In this language, you can execute any of the commands exported by the
application, passing any number of arguments they need. Arguments to function
calls can, but need not, be quoted. Quoting is only mandatory when they
contain spaces, newline characters, or double-quotes ('"'). To quote an
argument, surround it by double-quotes, and precede each double-quote it
contains by a backslash character. Another way of quoting is similar to
what python provides, which is to triple-quote the argument, ie surround it
by '"""' on each side. In such a case, any special character (in particular
other double-quotes or backslashes) lose their special meaning and are just
taken as part of the argument. This is in particular useful when you do not
know in advance the contents of the argument you are quoting.
@smallexample
Shell> function_name arg1 "arg 2" """arg 3"""
@end smallexample

Commands are executed as if on a stack machine: the result of a command is
pushed on the stack, and later commands can reference it using @code{%}
following by a number. By default, the number of previous results that are
kept is set to 9, and this can only be changed by modifying the source code
for @value{gnatlib}. The return values are also modified by commands executed
internally by your application, and that might have no visible output from
the user's point of view. As a result, you should never assume you know
what @code{%1},@dots{} contain unless you just executed a command in the
same script.
@smallexample
Shell> function_name arg1
Shell> function2_name %1
@end smallexample

In particular, the @code{%1} syntax is used when emulating object-oriented
programming in the shell. A method of a class is just a particular function
that contains a '.' in its name, and whose first implict argument is the
instance on which it applies. This instance is generally the result of
calling a constructor in an earlier call. Assuming, for instance, that we
have exported a class "Base" to the shell from our Ada core, we could use
the following code:
@smallexample
Shell> Base arg1 arg2
Shell> Base.method %1 arg1 arg2
@end smallexample
to create an instance and call one of its methods.
Of course, the shell is not the best language for object-oriented programming,
and better languages should be used instead.

@subsubsection Predefined commands
@noindent
Some commands are automatically added to the shell when this scripting
language is added to the application. These are

@table @bullet
@item "load file"
Loads the content of the file from the disk, and execute each of its lines as
a Shell command. This can for instance be used to load scripts when your
application is loaded

@item "echo arg1 arg2..."
This function takes any number of argument, and prints them in the console
associated with the language. By default, when in an interactive console, the
output of commands is automatically printed to the console. But when you
execute a script through @code{load} above, you need to explicitly call
@code{echo} to make some output visible.

@item "clear_cache"
This frees the memory used to store the output of previous commands. Calling
@code{%1} afterward will not make sense until further commands are executed.
@end table

@c ----------------------------------------------------------------------
@node The Python language
@subsection The Python language
@c ----------------------------------------------------------------------

@noindent

@bye

